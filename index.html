<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f19" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="./icons/icon-192.png?v=30">
  <title>VR Offline</title>
  <link rel="manifest" href="./manifest.json?v=30" />
  <style>
    :root { --bg:#0b0f19; --fg:#e5e7eb; --muted:#9aa3b2; --panel: rgba(11,15,25,.65); }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      overscroll-behavior:none; }
    #app { position:fixed; inset:0; overflow:hidden; z-index:0; }
    canvas { display:block; width:100%; height:100%; background:#000; }

    /* Main UI (overlay appears only in VR; no recenter here) */
    .ui { position:fixed; inset:0; display:grid; place-items:center; z-index:10; pointer-events:auto; }
    .ui-inner { display:flex; flex-direction:column; gap:.8rem; align-items:center; }
    h1.appTitle { margin:0 0 .35rem; font-size:1.5rem; font-weight:700; letter-spacing:.2px;
      font-style:italic; color:#22c55e; } /* GREEN marker */
    .title { font-style:italic; color:var(--muted); font-size:.9rem; margin-top:.25rem; }

    button { appearance:none; border:0; padding:1rem 1.2rem; border-radius:1rem;
      background:#121a2b; color:var(--fg); font-weight:600; letter-spacing:.2px;
      box-shadow:0 6px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
      width:220px; cursor:pointer; }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity:.5; cursor:not-allowed; }

    .hidden { opacity:0; transform:translateY(8px); pointer-events:none; }
    .visible { opacity:1; transform:translateY(0); }
    .fade { transition:opacity .25s ease, transform .25s ease; }

    #file { position:fixed; width:1px; height:1px; opacity:0; pointer-events:none; }
    #tapPrompt { position:fixed; left:50%; bottom:18px; transform:translateX(-50%); z-index:11;
      display:none; padding:.7rem 1rem; border-radius:12px; background:var(--panel); border:1px solid #263044; font-weight:600; }

    /* VR overlay (only in VR; background click-through) */
    #vrControls { position:fixed; inset:0; z-index:12; display:none; pointer-events:none; }
    #vrControls .panel { pointer-events:auto; background:var(--panel); border:1px solid #263044; border-radius:12px;
      box-shadow:0 6px 24px rgba(0,0,0,.35); backdrop-filter:blur(6px); }

    /* IPD (top, horizontal, 1–10) */
    #ipdPanel { position:absolute; left:50%; top:8px; transform:translateX(-50%); padding:8px 10px; }
    #ipdLabel { font-size:12px; color:var(--muted); margin-bottom:6px; text-align:center; }
    #ipdWrap { display:flex; align-items:center; gap:10px; }
    #ipd { width:60vw; max-width:560px; }
    #ipdVal { min-width:2ch; text-align:center; font-weight:700; }

    /* Zoom (right, vertical, 1–10) */
    #zoomPanel { position:absolute; right:8px; top:50%; transform:translateY(-50%); padding:8px 10px;
      display:flex; flex-direction:column; align-items:center; gap:6px; }
    #zoomLabel { font-size:12px; color:var(--muted); text-align:center; }
    #zoomVal { font-weight:700; }
    #zoom { writing-mode:bt-lr; -webkit-appearance:slider-vertical; appearance:slider-vertical; height:40vh; max-height:360px; }

    /* Bottom center (Recenter) */
    #actionBar { position:absolute; left:50%; bottom:10px; transform:translateX(-50%); padding:8px 10px;
      display:flex; gap:10px; align-items:center; justify-content:center; }
    #recenterVrBtn { width:auto; padding:.8rem 1.1rem; }

    datalist { display:none; } /* ticks drawing is browser-dependent */
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="ui">
    <div id="ui" class="ui-inner fade visible">
      <h1 class="appTitle">VR Offline</h1>
      <button id="selectBtn" type="button">Select simulation</button>
      <button id="vrBtn" type="button">Enter VR</button>
      <button id="installBtn" type="button">Download app</button>
      <div class="title">Brought to you by Cambridge XR</div>
    </div>
  </div>

  <input id="file" type="file" accept="video/*" />
  <button id="tapPrompt" type="button">Tap to start video</button>

  <!-- Overlay (only visible in VR mode) -->
  <div id="vrControls">
    <div id="ipdPanel" class="panel">
      <div id="ipdLabel">IPD / Lens gap (Cardboard)</div>
      <div id="ipdWrap">
        <input id="ipd" type="range" min="1" max="10" step="1" value="1" list="ipdTicks" />
        <output id="ipdVal">1</output>
      </div>
      <datalist id="ipdTicks"><option value="1"></option><option value="2"></option><option value="3"></option><option value="4"></option><option value="5"></option><option value="6"></option><option value="7"></option><option value="8"></option><option value="9"></option><option value="10"></option></datalist>
    </div>
    <div id="zoomPanel" class="panel">
      <div id="zoomLabel">Zoom</div>
      <output id="zoomVal">1</output>
      <input id="zoom" type="range" min="1" max="10" step="1" value="1" list="zoomTicks" />
      <datalist id="zoomTicks"><option value="1"></option><option value="2"></option><option value="3"></option><option value="4"></option><option value="5"></option><option value="6"></option><option value="7"></option><option value="8"></option><option value="9"></option><option value="10"></option></datalist>
    </div>
    <div id="actionBar" class="panel">
      <button id="recenterVrBtn" type="button">Recenter</button>
    </div>
  </div>

  <!-- three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/DeviceOrientationControls.js"></script>

  <script>
  (function(){
    const app = document.getElementById('app');
    const ui  = document.getElementById('ui');

    const selectBtn   = document.getElementById('selectBtn');
    const vrBtn       = document.getElementById('vrBtn');
    const installBtn  = document.getElementById('installBtn');
    const fileInput   = document.getElementById('file');
    const tapPrompt   = document.getElementById('tapPrompt');

    // Power helpers
    let wakeLock = null;
    async function requestWakeLock(){ try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch(e){} }

    // iOS orientation permission (Chrome/Safari on iOS)
    async function ensureOrientationPermission(){
      try {
        const D = window.DeviceOrientationEvent;
        if (D && typeof D.requestPermission === 'function') {
          const r = await D.requestPermission();
          return r === 'granted';
        }
      } catch(e){}
      return true;
    }

    // Scene
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = false; // Cardboard only
    app.appendChild(renderer.domElement);

    // Video -> sphere
    const video = document.createElement('video');
    video.setAttribute('playsinline',''); video.playsInline = true; video.loop = true; video.preload = 'metadata'; video.crossOrigin = 'anonymous';
    const geom = new THREE.SphereGeometry(500, 64, 64); geom.scale(-1,1,1);
    const tex  = new THREE.VideoTexture(video); tex.colorSpace = THREE.SRGBColorSpace;
    const mat  = new THREE.MeshBasicMaterial({ map: tex });
    const sphere = new THREE.Mesh(geom, mat); scene.add(sphere);

    // Orientation controls
    let controls = null;
    try { if (THREE.DeviceOrientationControls) { controls = new THREE.DeviceOrientationControls(camera, true); controls.connect(); } } catch(e){}

    // State
    let yawOffset = 0;
    let mode = 'mono'; // 'mono' | 'stereo'
    const SMOOTH_ALPHA = 0.12;
    const smoothedQuat = new THREE.Quaternion().copy(camera.quaternion);
    let ipdGapPct = 0.0; // 0..0.2, from slider 1..10
    camera.fov = 75; camera.updateProjectionMatrix();
    let snapNextFrame = false;
    let currentObjectURL = null;
    let overlayVisible = false;

    // UI show/hide (disabled in VR)
    let uiTimer = null;
    function showUI(){ if (mode==='stereo') return; ui.classList.remove('hidden'); ui.classList.add('visible'); clearTimeout(uiTimer); uiTimer = setTimeout(hideUI, 2500); }
    function hideUI(){ ui.classList.remove('visible'); ui.classList.add('hidden'); }
    function globalTapHandler(e){
      if (mode === 'stereo') return; // never steal taps in VR
      const onUI = e.target.closest('#ui');
      if (!onUI) { showUI(); if (video.src && video.paused) video.play().catch(()=>{}); }
    }
    document.addEventListener('pointerdown', globalTapHandler, { capture:true, passive:true });
    uiTimer = setTimeout(hideUI, 3000);

    // Ensure VR button clicks aren't intercepted
    ['pointerdown','click','touchstart'].forEach(evt => {
      vrBtn.addEventListener(evt, ev => ev.stopPropagation(), { capture:true });
    });

    // Tap-to-start helper
    function showTap(){ tapPrompt.style.display = 'block'; }
    function hideTap(){ tapPrompt.style.display = 'none'; }
    tapPrompt.addEventListener('click', () => { video.muted = true; video.play().then(hideTap).catch(()=>{}); });

    // File selection
    selectBtn.addEventListener('click', () => {
      showUI();
      fileInput.value = '';
      if (fileInput.showPicker) { try { fileInput.showPicker(); return; } catch(e){} }
      fileInput.click();
    });
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      if (currentObjectURL) { try { URL.revokeObjectURL(currentObjectURL); } catch{} currentObjectURL = null; }
      currentObjectURL = URL.createObjectURL(file);
      try { video.pause(); } catch{}
      video.removeAttribute('src'); video.srcObject = null; video.load();
      video.src = currentObjectURL; video.currentTime = 0;
      video.muted = false;
      const p = video.play();
      if (p && typeof p.catch === 'function') {
        p.then(hideTap).catch(() => { video.muted = true; video.play().then(hideTap).catch(showTap); });
      }
    });

    // Recenter
    function recenter(){
      const e = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      yawOffset = e.y; snapNextFrame = true;
    }

    // Overlay & sliders
    const vrControls = document.getElementById('vrControls');
    const ipdSlider  = document.getElementById('ipd');
    const ipdVal     = document.getElementById('ipdVal');
    const zoomSlider = document.getElementById('zoom');
    const zoomVal    = document.getElementById('zoomVal');
    const recenterVrBtn = document.getElementById('recenterVrBtn');

    function mapIpd(v){ return ((v - 1) / 9) * 0.20; } // 1..10 -> 0..0.2
    function mapZoomToFov(v){ const min=30, max=100; return max - ((v - 1) / 9) * (max - min); } // 1->100, 10->30

    function showOverlay(show){ overlayVisible = !!show; vrControls.style.display = overlayVisible ? 'block' : 'none'; }
    function toggleOverlay(ev){
      if (mode !== 'stereo') return;
      if (ev && ev.composedPath && ev.composedPath().some(el => el && el.classList && el.classList.contains('panel'))) return;
      ev && ev.preventDefault();
      showOverlay(!overlayVisible);
    }
    renderer.domElement.addEventListener('pointerdown', toggleOverlay, { capture:true });

    recenterVrBtn.addEventListener('click', (e) => { e.stopPropagation(); recenter(); });
    zoomSlider.addEventListener('input', () => {
      const v = parseInt(zoomSlider.value, 10); zoomVal.textContent = String(v);
      camera.fov = mapZoomToFov(v); camera.updateProjectionMatrix();
    });
    ipdSlider.addEventListener('input', () => {
      const v = parseInt(ipdSlider.value, 10); ipdVal.textContent = String(v); ipdGapPct = mapIpd(v);
    });
    zoomSlider.dispatchEvent(new Event('input')); ipdSlider.dispatchEvent(new Event('input'));

    // Sizing
    function forceResize(){
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', forceResize);

    // RENDER
    function updateVideoTexture(){ if (video.readyState >= 2) tex.needsUpdate = true; }
    function renderMono(){
      controls && controls.update();
      const e = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ'); e.y -= yawOffset;
      const target = new THREE.Quaternion().setFromEuler(e);
      if (snapNextFrame){ camera.quaternion.copy(target); smoothedQuat.copy(target); snapNextFrame=false; }
      else { smoothedQuat.slerp(target, SMOOTH_ALPHA); camera.quaternion.copy(smoothedQuat); }
      updateVideoTexture();
      renderer.setScissorTest(false);
      renderer.render(scene, camera);
    }
    function renderStereo(){
      controls && controls.update();

      const e = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ'); e.y -= yawOffset;
      const target = new THREE.Quaternion().setFromEuler(e);
      if (snapNextFrame){ camera.quaternion.copy(target); smoothedQuat.copy(target); snapNextFrame=false; }
      else { smoothedQuat.slerp(target, SMOOTH_ALPHA); camera.quaternion.copy(smoothedQuat); }

      // Use the canvas internal size (this matched your earlier working build)
      let w = renderer.domElement.width|0, h = renderer.domElement.height|0;
      if (!w || !h) {
        const size = renderer.getSize(new THREE.Vector2());
        const dpr  = renderer.getPixelRatio();
        w = Math.max(1, (size.x * dpr)|0);
        h = Math.max(1, (size.y * dpr)|0);
      }

      const half = (w/2)|0;
      const gap  = (w * ipdGapPct)|0;
      const leftW = (half - (gap/2))|0;
      const rightX = (half + (gap/2))|0;
      const rightW = Math.max(1, (w - rightX)|0);

      updateVideoTexture();
      renderer.setScissorTest(true);

      // Left eye
      renderer.setViewport(0, 0, leftW, h);
      renderer.setScissor(0, 0, leftW, h);
      camera.aspect = leftW / h; camera.updateProjectionMatrix();
      renderer.render(scene, camera);

      // Right eye
      renderer.setViewport(rightX, 0, rightW, h);
      renderer.setScissor(rightX, 0, rightW, h);
      camera.aspect = rightW / h; camera.updateProjectionMatrix();
      renderer.render(scene, camera);

      renderer.setScissorTest(false);
    }
    function animate(){ requestAnimationFrame(animate); (mode === 'stereo') ? renderStereo() : renderMono(); }
    animate();

    // ENTER VR — split-screen immediately; extras in parallel
    function enterVR(ev){
      if (ev){ ev.preventDefault(); ev.stopPropagation(); }

      // 1) Flip to stereo NOW (forces split-screen next frame)
      mode = 'stereo';
      ui.classList.add('hidden');
      forceResize();
      showOverlay(true);
      setTimeout(()=>{ if (mode==='stereo') showOverlay(false); }, 1200);

      // 2) Ask for orientation permission & (re)connect controls
      ensureOrientationPermission().then(() => { try { controls && controls.connect(); } catch(e){}; }).catch(()=>{});

      // 3) Try fullscreen on canvas; orientation lock; wakelock (best effort)
      try {
        const c = renderer.domElement;
        if (c.requestFullscreen) c.requestFullscreen();
        else if (c.webkitRequestFullscreen) c.webkitRequestFullscreen();
        else if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
      } catch(e){}
      try { screen.orientation.lock('landscape').catch(()=>{}); } catch(e){}
      requestWakeLock();

      // 4) Extra resizes after possible fullscreen/orientation settle
      setTimeout(forceResize, 120);
      setTimeout(forceResize, 320);
    }
    vrBtn.addEventListener('click', enterVR, { passive:false });

    // INSTALL (Download app)
    let deferredPrompt = null;
    window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); deferredPrompt = e; });
    installBtn.addEventListener('click', async () => {
      if (deferredPrompt) { deferredPrompt.prompt(); try { await deferredPrompt.userChoice; } finally { deferredPrompt = null; } }
      else {
        const ua = navigator.userAgent || '';
        if (/iPhone|iPad|iPod/i.test(ua)) alert('To install: tap Share, then "Add to Home Screen".');
        else alert('To install: open the browser menu and choose "Install App" (or "Add to Home Screen").');
      }
    });

    // Drag & drop + gesture guard
    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => {
      e.preventDefault();
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file && file.type.startsWith('video/')) {
        if (currentObjectURL) { try { URL.revokeObjectURL(currentObjectURL); } catch{} currentObjectURL = null; }
        currentObjectURL = URL.createObjectURL(file);
        try { video.pause(); } catch{} video.removeAttribute('src'); video.srcObject = null; video.load();
        video.src = currentObjectURL; video.muted = true;
        video.play().then(hideTap).catch(showTap);
      }
    });

    // Service worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          const reg = await navigator.serviceWorker.register('./sw.js?v=30', { scope: './' });
          if (reg.waiting) reg.waiting.postMessage('SKIP_WAITING');
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!window.__reloaded) { window.__reloaded = true; location.reload(); }
          });
        } catch (e) { console.warn('SW registration failed', e); }
      });
    }
  })();
  </script>
</body>
</html>
