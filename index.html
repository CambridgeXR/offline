<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f19" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="./icons/icon-192.png?v=15">
  <title>VR Offline</title>
  <link rel="manifest" href="./manifest.json?v=15" />
  <style>
    :root { --bg:#0b0f19; --fg:#e5e7eb; --muted:#9aa3b2; --panel: rgba(11,15,25,.65); }
    html,body {
      height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      overscroll-behavior: none;
    }
    #app { position:fixed; inset:0; overflow:hidden; z-index:0; }
    canvas { display:block; width:100%; height:100%; }

    /* UI sits above canvas and accepts pointer events */
    .ui { position:fixed; inset:0; display:grid; place-items:center; z-index:10; pointer-events:auto; }
    .ui-inner { display:flex; flex-direction:column; gap:.8rem; align-items:center; }

    h1.appTitle {
      margin:0 0 .35rem;
      font-size:1.5rem;
      font-weight:700;
      letter-spacing:.2px;
      font-style: italic;
      color:#3b82f6; /* BLUE so you know this build loaded */
    }
    .title { font-style: italic; color: var(--muted); font-size:.9rem; margin-top:.25rem; }

    button {
      appearance:none; border:0; padding:1rem 1.2rem; border-radius:1rem;
      background:#121a2b; color:var(--fg); font-weight:600; letter-spacing:.2px;
      box-shadow:0 6px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
      width:220px; cursor:pointer;
    }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity:.5; cursor:not-allowed; }

    /* Show/Hide with fade */
    .hidden { opacity:0; transform: translateY(8px); pointer-events:none; }
    .visible { opacity:1; transform: translateY(0); }
    .fade { transition: opacity .25s ease, transform .25s ease; }

    /* File input: invisible (not display:none) for programmatic open on Android */
    #file { position:fixed; width:1px; height:1px; opacity:0; pointer-events:none; }

    /* VR Controls overlay (shown on tap while in VR) */
    #vrControls { position: fixed; inset: 0; pointer-events: none; z-index: 12; display:none; }
    #vrControls .panel {
      pointer-events:auto; background:var(--panel); border:1px solid #263044; border-radius:12px;
      box-shadow:0 6px 24px rgba(0,0,0,.35); backdrop-filter: blur(6px);
    }

    /* Top horizontal (IPD) */
    #ipdPanel { position:absolute; left:50%; top:8px; transform:translateX(-50%); padding:8px 10px; }
    #ipdLabel { font-size:12px; color:var(--muted); margin-bottom:6px; text-align:center; }
    #ipd { width:60vw; max-width:560px; }

    /* Right vertical (Zoom) */
    #zoomPanel { position:absolute; right:8px; top:50%; transform:translateY(-50%); padding:8px 10px;
      display:flex; flex-direction:column; align-items:center; gap:6px; }
    #zoomLabel { font-size:12px; color:var(--muted); }
    #zoom {
      writing-mode: bt-lr; -webkit-appearance: slider-vertical; appearance: slider-vertical;
      height:40vh; max-height:360px;
    }

    /* Bottom center action bar with Recenter (visible in VR overlay) */
    #actionBar {
      position:absolute; left:50%; bottom:10px; transform:translateX(-50%);
      padding:8px 10px; display:flex; gap:10px; align-items:center; justify-content:center;
    }
    #recenterVrBtn { width:auto; padding:.8rem 1.1rem; }
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- Minimal UI -->
  <div class="ui">
    <div id="ui" class="ui-inner fade visible">
      <h1 class="appTitle">VR Offline</h1>
      <button id="selectBtn" type="button">Select simulation</button>
      <button id="vrBtn" type="button" disabled>Enter VR</button>
      <button id="recenterBtn" type="button">Recenter</button>
      <button id="installBtn" type="button" style="display:none;">Install App</button>
      <div class="title">Brought to you by Cambridge XR</div>
    </div>
  </div>

  <!-- Hidden (but clickable) input for local video selection -->
  <input id="file" type="file" accept="video/*" />

  <!-- VR overlays (shown in VR on tap) -->
  <div id="vrControls">
    <div id="ipdPanel" class="panel">
      <div id="ipdLabel">IPD / Lens gap (Cardboard)</div>
      <input id="ipd" type="range" min="0" max="20" value="0" />
    </div>
    <div id="zoomPanel" class="panel">
      <div id="zoomLabel">Zoom</div>
      <input id="zoom" type="range" min="30" max="100" value="75" />
    </div>
    <div id="actionBar" class="panel">
      <button id="recenterVrBtn" type="button">Recenter</button>
    </div>
  </div>

  <!-- three.js core -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/DeviceOrientationControls.js"></script>

  <script>
  (function(){
    const app = document.getElementById('app');

    // Power helpers
    let wakeLock = null;
    async function requestWakeLock(){ try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch(e){} }
    document.addEventListener('visibilitychange', async () => {
      if (wakeLock !== null && document.visibilityState === 'visible') { try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){} }
    });
    async function goFullscreen(){
      const el = document.documentElement;
      try { if (el.requestFullscreen) await el.requestFullscreen(); else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen(); } catch(e){}
    }

    // Video (same flow you confirmed worked)
    const video = document.createElement('video');
    video.setAttribute('playsinline','');
    video.loop = true; video.preload = 'metadata'; video.crossOrigin = 'anonymous';

    // Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    app.appendChild(renderer.domElement);

    // 360 sphere
    const geometry = new THREE.SphereGeometry(500, 64, 64);
    geometry.scale(-1, 1, 1);
    const texture = new THREE.VideoTexture(video);
    texture.colorSpace = THREE.SRGBColorSpace;
    const material = new THREE.MeshBasicMaterial({ map: texture });
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // Orientation controls â€” guard against errors
    let controls = null;
    try {
      if (THREE.DeviceOrientationControls) {
        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
      }
    } catch (e) { console.warn('DeviceOrientationControls unavailable; continuing.'); }

    // State
    let yawOffset = 0;
    let mode = 'mono'; // 'mono' | 'stereo' | 'webxr'
    const SMOOTH_ALPHA = 0.12;
    const smoothedQuat = new THREE.Quaternion().copy(camera.quaternion);

    // Stereo (Cardboard) params
    let ipdGapPct = 0.0;                // 0..0.2 of screen width (slider 0..20)
    camera.fov = 75; camera.updateProjectionMatrix(); // zoom slider controls this

    // XR reference spaces
    let xrBaseRefSpace = null;

    /* ----------------------- RECENTER ----------------------- */
    function recenter(){
      if (mode === 'webxr') {
        // Preferred: offset XR reference space to create a new anchor
        const refBase = xrBaseRefSpace || (renderer.xr.getReferenceSpace && renderer.xr.getReferenceSpace());
        if (refBase && window.XRRigidTransform) {
          const xrCam = renderer.xr.getCamera(); // XR camera
          const euler = new THREE.Euler().setFromQuaternion(xrCam.quaternion, 'YXZ');
          const yaw = euler.y;
          const half = -yaw / 2; // inverse yaw
          const orientation = new DOMPointReadOnly(0, Math.sin(half), 0, Math.cos(half));
          const offsetRefSpace = refBase.getOffsetReferenceSpace(new XRRigidTransform(undefined, orientation));
          renderer.xr.setReferenceSpace(offsetRefSpace);
        } else {
          // Fallback: rotate the sphere like your original
          const xrCam = renderer.xr.getCamera();
          const e = new THREE.Euler().setFromQuaternion(xrCam.quaternion, 'YXZ');
          sphere.rotation.y = -e.y;
        }
      } else {
        const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
        yawOffset = euler.y;
      }
    }

    /* --------------------- RENDER LOOPS ---------------------- */
    function renderMono(){
      if (controls) controls.update();
      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      euler.y -= yawOffset;
      const targetQuat = new THREE.Quaternion().setFromEuler(euler);
      smoothedQuat.slerp(targetQuat, SMOOTH_ALPHA);
      camera.quaternion.copy(smoothedQuat);
      renderer.setScissorTest(false);
      renderer.render(scene, camera);
    }

    function renderStereo(){
      if (controls) controls.update();
      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      euler.y -= yawOffset;
      const targetQuat = new THREE.Quaternion().setFromEuler(euler);
      smoothedQuat.slerp(targetQuat, SMOOTH_ALPHA);
      camera.quaternion.copy(smoothedQuat);

      const w = renderer.domElement.width | 0, h = renderer.domElement.height | 0;
      const half = w / 2;
      const gap = (w * ipdGapPct) | 0; // central gap in px
      const leftW  = (half - (gap / 2)) | 0;
      const rightX = (half + (gap / 2)) | 0;
      const rightW = (w - rightX) | 0;

      renderer.setScissorTest(true);

      // Left eye
      renderer.setViewport(0, 0, leftW, h);
      renderer.setScissor(0, 0, leftW, h);
      camera.aspect = leftW / h; camera.updateProjectionMatrix();
      renderer.render(scene, camera);

      // Right eye
      renderer.setViewport(rightX, 0, rightW, h);
      renderer.setScissor(rightX, 0, rightW, h);
      camera.aspect = rightW / h; camera.updateProjectionMatrix();
      renderer.render(scene, camera);

      renderer.setScissorTest(false);
    }

    const xrLoop = () => { renderer.render(scene, camera); };

    function animate(){
      if (mode === 'webxr') return; // XR uses setAnimationLoop
      requestAnimationFrame(animate);
      (mode === 'stereo') ? renderStereo() : renderMono();
    }
    animate();

    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    /* ------------------- UI show/hide ------------------- */
    const ui = document.getElementById('ui');
    let uiTimer = null;

    function showUI(){
      ui.classList.remove('hidden');
      ui.classList.add('visible');
      clearTimeout(uiTimer);
      uiTimer = setTimeout(hideUI, 2500);
    }
    function hideUI(){
      ui.classList.remove('visible');
      ui.classList.add('hidden');
    }

    // Global capture listener ensures we get the event before canvas/others
    function globalTapHandler(e){
      // If tap was NOT on a UI control, just show the UI
      const onUI = e.target.closest('#ui');
      if (!onUI) {
        showUI();
        if (video.src && video.paused) video.play().catch(()=>{});
      }
    }
    document.addEventListener('pointerdown', globalTapHandler, { capture:true, passive:true });
    document.addEventListener('click',       globalTapHandler, { capture:true, passive:true });
    // Start hidden after a short delay
    uiTimer = setTimeout(hideUI, 3000);

    // Buttons
    const selectBtn   = document.getElementById('selectBtn');
    const vrBtn       = document.getElementById('vrBtn');
    const recenterBtn = document.getElementById('recenterBtn');
    const installBtn  = document.getElementById('installBtn');
    const fileInput   = document.getElementById('file');

    // Stop bubbling so a button press doesn't trigger the global handler twice
    ['pointerdown','click','touchstart'].forEach(evt => {
      for (const el of [selectBtn, vrBtn, recenterBtn, installBtn]) {
        el.addEventListener(evt, e => e.stopPropagation(), { passive:true });
      }
    });

    // Select simulation: open file picker and enable VR when playing
    selectBtn.addEventListener('click', () => {
      showUI(); // keep controls visible after action
      fileInput.value = ''; // allow re-select same file
      if (fileInput.showPicker) { try { fileInput.showPicker(); return; } catch(e){} }
      fileInput.click();
    });

    // Start playback directly inside the 'change' handler (user gesture)
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      startVideo(url);
    });

    function startVideo(src){
      // Reset and set new source
      try { video.pause(); } catch {}
      video.removeAttribute('src'); video.srcObject = null; video.load();

      video.src = src;
      video.currentTime = 0;

      // Try unmuted first, then muted fallback
      video.muted = false;
      video.play().then(() => {
        vrBtn.disabled = false;
      }).catch(() => {
        video.muted = true;
        video.play().then(() => { vrBtn.disabled = false; }).catch(()=>{});
      });
    }

    /* --------------------- VR overlays & actions --------------------- */
    const vrControls = document.getElementById('vrControls');
    const ipdSlider  = document.getElementById('ipd');
    const ipdLabel   = document.getElementById('ipdLabel');
    const zoomSlider = document.getElementById('zoom');
    const recenterVrBtn = document.getElementById('recenterVrBtn');

    function toggleVRControls(ev){
      if (mode === 'mono') return;
      // ignore taps on panels so sliders remain usable
      if (ev && ev.composedPath && ev.composedPath().some(el => el && el.classList && el.classList.contains('panel'))) return;
      const show = (vrControls.style.display === 'none' || vrControls.style.display === '');
      vrControls.style.display = show ? 'block' : 'none';
      const disableIPD = (mode === 'webxr');
      ipdSlider.disabled = disableIPD;
      ipdLabel.textContent = disableIPD ? 'IPD / Lens gap (controlled by headset)' : 'IPD / Lens gap (Cardboard)';
    }

    // Show/hide sliders & recenter button on tap in VR
    renderer.domElement.addEventListener('pointerdown', toggleVRControls);

    // Also allow recenter from the VR overlay
    recenterVrBtn.addEventListener('click', (e) => { e.stopPropagation(); recenter(); });

    // Zoom (Cardboard only â€“ adjusts camera FOV)
    zoomSlider.addEventListener('input', () => {
      camera.fov = parseFloat(zoomSlider.value); // 30..100 (smaller = more zoom)
      camera.updateProjectionMatrix();
    });

    // IPD gap (Cardboard only â€“ adjusts the center gap between viewports)
    ipdSlider.addEventListener('input', () => {
      const v = parseInt(ipdSlider.value, 10); // 0..20
      ipdGapPct = Math.min(0.2, Math.max(0, v / 100)); // 0..0.2
    });

    /* --------------------------- VR entry ------------------------ */
    async function enterCardboard(){
      await goFullscreen();
      try { await screen.orientation.lock('landscape'); } catch {}
      await requestWakeLock();
      mode = 'stereo';
      showUI();
      // Briefly show VR controls on enter
      vrControls.style.display = 'block';
      setTimeout(()=>{ if (mode==='stereo') vrControls.style.display = 'none'; }, 1200);
    }

    async function enterWebXR(){
      try {
        const supported = await (navigator.xr && navigator.xr.isSessionSupported ? navigator.xr.isSessionSupported('immersive-vr') : Promise.resolve(false));
        if (!supported) return false;

        const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor','bounded-floor','local'] });
        renderer.xr.setReferenceSpaceType('local');
        await renderer.xr.setSession(session);

        // Get and store a base reference space; recenter offsets are relative to this
        xrBaseRefSpace = await session.requestReferenceSpace('local');
        if (xrBaseRefSpace) renderer.xr.setReferenceSpace(xrBaseRefSpace);

        // Make controller 'select' act as a recenter in WebXR (since HTML overlay isnâ€™t visible in immersive mode)
        session.addEventListener('select', () => { recenter(); });

        renderer.setAnimationLoop(xrLoop);
        mode = 'webxr';
        return true;
      } catch (e) { return false; }
    }

    async function enterVR(){
      showUI();
      const ok = await enterWebXR();
      if (!ok) await enterCardboard();
    }
    const vrBtn = document.getElementById('vrBtn');
    vrBtn.addEventListener('click', enterVR);

    // Recenter (top-level UI button)
    const recenterBtn = document.getElementById('recenterBtn');
    recenterBtn.addEventListener('click', () => { showUI(); recenter(); });

    // PWA install: show + auto-prompt on next tap after eligibility
    const installBtn  = document.getElementById('installBtn');
    let deferredPrompt = null;
    let autoPrompted = false;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'block';
      const auto = () => {
        if (deferredPrompt && !autoPrompted) {
          autoPrompted = true;
          deferredPrompt.prompt();
          deferredPrompt.userChoice.finally(() => {
            deferredPrompt = null;
            installBtn.style.display = 'none';
          });
        }
        window.removeEventListener('pointerdown', auto, { capture:true });
      };
      window.addEventListener('pointerdown', auto, { once:true, capture:true });
      showUI();
    });

    installBtn.addEventListener('click', async () => {
      showUI();
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      try { await deferredPrompt.userChoice; } finally {
        deferredPrompt = null;
        installBtn.style.display = 'none';
      }
    });
    window.addEventListener('appinstalled', () => { installBtn.style.display = 'none'; });

    // Drag & drop + gesture guard
    document.addEventListener('dragover', e => { e.preventDefault(); });
    document.addEventListener('drop', e => {
      e.preventDefault();
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file && file.type.startsWith('video/')) startVideo(URL.createObjectURL(file));
    });
    window.addEventListener('touchmove', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive:false });

    // cache-busted SW registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          const reg = await navigator.serviceWorker.register('./sw.js?v=15', { scope: './' });
          if (reg.waiting) reg.waiting.postMessage('SKIP_WAITING');
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!window.__reloaded) { window.__reloaded = true; location.reload(); }
          });
        } catch (e) { console.warn('SW registration failed', e); }
      });
    }
  })();
  </script>
</body>
</html>
