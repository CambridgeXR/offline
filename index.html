<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f19" />
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="./icons/icon-192.png?v=13">
  <title>VR Offline</title>
  <link rel="manifest" href="./manifest.json?v=13" />
  <style>
    :root { --bg:#0b0f19; --fg:#e5e7eb; --muted:#9aa3b2; }
    html,body {
      height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    }
    #app, canvas { width:100%; height:100%; display:block; }
    .ui {
      position: fixed; inset: 0; display: grid; place-items: center;
      z-index: 10; /* keep UI clickable */
    }
    .ui-inner {
      display:flex; flex-direction:column; align-items:center; gap:12px;
      padding:16px 18px; border-radius:14px; background:rgba(11,15,25,.65); backdrop-filter: blur(6px);
      box-shadow: 0 6px 24px rgba(0,0,0,.35);
      max-width:min(92vw, 520px);
    }
    .fade { opacity:0; transform: translateY(6px); transition:opacity .25s ease, transform .25s ease; }
    .fade.visible { opacity:1; transform: translateY(0); }
    h1 { margin: 0 0 6px; font-size: 20px; font-weight: 600; letter-spacing: .2px; }
    .appTitle, .title { font-style: italic; } /* italics */
    .title { font-size: 12px; color: var(--muted); margin-top: 4px; }
    button {
      -webkit-tap-highlight-color: transparent;
      padding:10px 14px; border-radius:10px; border:1px solid #263044; background:#151b29; color:var(--fg);
      font-size: 14px; font-weight: 600; letter-spacing: .2px; cursor: pointer; min-width: 200px;
    }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    #recenterBtn { min-width: 200px; } /* match others */
    /* Hidden video stays in DOM for iOS autoplay policies */
    #player {
      position: fixed; left: -10000px; top: -10000px; width: 1px; height: 1px; opacity: 0; pointer-events: none;
    }
    /* File input: invisible (not display:none) for programmatic open on Android */
    #file { position:fixed; width:1px; height:1px; opacity:0; pointer-events:none; }
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- Minimal UI -->
  <div class="ui">
    <div id="ui" class="ui-inner fade visible">
      <h1 class="appTitle">VR Offline</h1>
      <button id="selectBtn" type="button">Select simulation</button>
      <button id="vrBtn" type="button" disabled>Enter VR</button>
      <button id="recenterBtn" type="button">Recenter</button>
      <button id="installBtn" type="button" style="display:none;">Install App</button>
      <div class="title">Brought to you by Cambridge XR</div>
    </div>
  </div>

  <!-- Hidden (but present) video + file input -->
  <video id="player" playsinline webkit-playsinline muted loop controls></video>
  <input id="file" type="file" accept="video/*" />

  <!-- three.js core -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/DeviceOrientationControls.js"></script>

  <script>
  (function(){
    const app = document.getElementById('app');
    const uiRoot = document.getElementById('ui');
    const selectBtn = document.getElementById('selectBtn');
    const vrBtn = document.getElementById('vrBtn');
    const recenterBtn = document.getElementById('recenterBtn');
    const installBtn = document.getElementById('installBtn');
    const fileInput = document.getElementById('file');
    const video = document.getElementById('player');

    // Ensure autoplay allowance + property flags
    video.muted = true;
    video.playsInline = true;
    video.setAttribute('muted', '');
    video.setAttribute('playsinline', '');
    video.setAttribute('webkit-playsinline', '');

    // Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    app.appendChild(renderer.domElement);

    // 360 sphere + texture
    const geometry = new THREE.SphereGeometry(500, 64, 64);
    geometry.scale(-1, 1, 1);
    let texture = new THREE.VideoTexture(video);
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.generateMipmaps = false;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    scene.add(new THREE.AmbientLight(0xffffff, 1.0));

    // Device orientation (Cardboard/mono fallback)
    let controls = null;
    try {
      controls = new THREE.DeviceOrientationControls(camera);
      controls.connect();
      document.addEventListener('click', () => { try { controls.enabled = true; } catch {} }, { once: true });
    } catch (e) { console.warn('DeviceOrientationControls unavailable; continuing.'); }

    // State
    let yawOffset = 0;
    let mode = 'mono'; // 'mono' | 'stereo' | 'webxr'
    const SMOOTH_ALPHA = 0.12;
    const smoothedQuat = new THREE.Quaternion().copy(camera.quaternion);
    let currentObjectURL = null;

    /* ----------------------- Video helpers ----------------------- */
    function armUserGesturePlay() {
      const tryPlay = () => {
        video.play().catch(()=>{});
        document.removeEventListener('pointerdown', tryPlay);
        document.removeEventListener('touchend', tryPlay);
        document.removeEventListener('keydown', tryPlay);
      };
      document.addEventListener('pointerdown', tryPlay, { once: true });
      document.addEventListener('touchend', tryPlay,  { once: true });
      document.addEventListener('keydown', tryPlay,   { once: true });
    }

    function waitForCanPlay() {
      return new Promise((resolve) => {
        if (video.readyState >= 3) return resolve(); // HAVE_FUTURE_DATA
        const onCanPlay = () => { video.removeEventListener('canplay', onCanPlay); resolve(); };
        video.addEventListener('canplay', onCanPlay);
        // Kick the pipeline
        try { video.load(); } catch {}
      });
    }

    video.addEventListener('playing', () => { if (texture) texture.needsUpdate = true; });
    video.addEventListener('loadeddata', () => { if (texture) texture.needsUpdate = true; });
    video.addEventListener('error', (e) => { console.warn('Video error', video.error); });

    /* ----------------------- Recenter (fixed) -------------------- */
    function recenter(){
      if (mode === 'webxr') {
        const refSpace = renderer.xr.getReferenceSpace && renderer.xr.getReferenceSpace();
        if (refSpace) {
          const xrCam = renderer.xr.getCamera(camera);
          const euler = new THREE.Euler().setFromQuaternion(xrCam.quaternion, 'YXZ');
          const yaw = euler.y;
          const half = -yaw / 2; // inverse yaw
          const orientation = new DOMPointReadOnly(0, Math.sin(half), 0, Math.cos(half));
          const offsetRefSpace = refSpace.getOffsetReferenceSpace(new XRRigidTransform(undefined, orientation));
          renderer.xr.setReferenceSpace(offsetRefSpace);
        }
        return;
      }
      const e = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      yawOffset = e.y;
    }

    /* ----------------------- Render loops ------------------------ */
    function renderMono(){
      if (controls) controls.update();
      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      euler.y -= yawOffset;
      const targetQuat = new THREE.Quaternion().setFromEuler(euler);
      smoothedQuat.slerp(targetQuat, SMOOTH_ALPHA);
      camera.quaternion.copy(smoothedQuat);
      renderer.setScissorTest(false);
      renderer.render(scene, camera);
    }

    function renderStereo(){
      if (controls) controls.update();
      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      euler.y -= yawOffset;
      const targetQuat = new THREE.Quaternion().setFromEuler(euler);
      smoothedQuat.slerp(targetQuat, SMOOTH_ALPHA);
      camera.quaternion.copy(smoothedQuat);
      const w = renderer.domElement.width, h = renderer.domElement.height;
      renderer.setScissorTest(true);
      renderer.setViewport(0, 0, w/2, h);   renderer.setScissor(0, 0, w/2, h);   renderer.render(scene, camera);
      renderer.setViewport(w/2, 0, w/2, h); renderer.setScissor(w/2, 0, w/2, h); renderer.render(scene, camera);
      renderer.setScissorTest(false);
    }

    const monoLoop = () => renderMono();
    const stereoLoop = () => renderStereo();
    const xrLoop = () => renderer.render(scene, camera);

    /* ----------------------- UI helpers -------------------------- */
    function showUI(){ requestAnimationFrame(()=>uiRoot.classList.add('visible')); }
    function enableVRButton(){ vrBtn.disabled = false; }

    /* ------------------- Local file selection -------------------- */
    async function selectLocal(){
      fileInput.value = ''; // allow re-pick same file
      fileInput.click();
      const file = await new Promise(resolve => {
        fileInput.onchange = () => resolve(fileInput.files?.[0] || null);
      });
      if (!file) return;

      if (currentObjectURL) URL.revokeObjectURL(currentObjectURL);
      currentObjectURL = URL.createObjectURL(file);

      try {
        video.srcObject = null;
        video.src = currentObjectURL;

        // Wait until the file can play, then try to start playback
        await waitForCanPlay();
        try {
          await video.play();
        } catch {
          armUserGesturePlay();
        }

        if (texture) texture.needsUpdate = true;
        enableVRButton();
      } catch (e) {
        console.warn('Could not load/play video', e);
        armUserGesturePlay();
      }
    }
    selectBtn.addEventListener('click', selectLocal);

    /* --------------------------- VR ------------------------------ */
    async function goFullscreen(){ try { if (document.fullscreenElement == null) await app.requestFullscreen(); } catch {} }
    async function requestWakeLock(){
      try { if ('wakeLock' in navigator) { const lock = await navigator.wakeLock.request('screen'); lock.addEventListener('release', ()=>{}); } } catch {}
    }

    async function enterCardboard(){
      await goFullscreen();
      try { await screen.orientation.lock('landscape'); } catch {}
      await requestWakeLock();
      video.play().catch(()=>armUserGesturePlay());
      mode = 'stereo';
      renderer.setAnimationLoop(stereoLoop);
      showUI();
    }

    async function enterWebXR(){
      try {
        const supported = await (navigator.xr && navigator.xr.isSessionSupported ? navigator.xr.isSessionSupported('immersive-vr') : Promise.resolve(false));
        if (!supported) return false;
        video.play().catch(()=>armUserGesturePlay());
        const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor','bounded-floor'] });
        renderer.xr.setReferenceSpaceType('local');
        await renderer.xr.setSession(session);          // set session first
        renderer.setAnimationLoop(xrLoop);              // then set loop
        mode = 'webxr';
        return true;
      } catch (e) { return false; }
    }

    async function enterVR(){
      showUI();
      const ok = await enterWebXR();
      if (!ok) await enterCardboard();
    }
    vrBtn.addEventListener('click', enterVR);

    // Recenter button
    recenterBtn.addEventListener('click', () => { showUI(); recenter(); });

    /* ---------------------- PWA install -------------------------- */
    let deferredPrompt = null;
    let autoPrompted = false;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.style.display = 'block';
      const auto = () => {
        if (deferredPrompt && !autoPrompted) {
          autoPrompted = true;
          deferredPrompt.prompt();
          deferredPrompt.userChoice.finally(() => {
            deferredPrompt = null;
            installBtn.style.display = 'none';
          });
        }
        document.removeEventListener('click', auto);
      };
      document.addEventListener('click', auto);
    });
    installBtn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
      installBtn.style.display = 'none';
    });

    /* -------------------------- Misc ----------------------------- */
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animation loop for mono/stereo until WebXR takes over
    renderer.setAnimationLoop(monoLoop);

    // iOS sensor permission on first tap
    document.addEventListener('click', async () => {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch {}
      }
    }, { once: true });

    // Service worker registration (unchanged)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          const reg = await navigator.serviceWorker.register('./sw.js?v=13', { scope: './' });
          if (reg.waiting) reg.waiting.postMessage('SKIP_WAITING');
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!window.__reloaded) { window.__reloaded = true; location.reload(); }
          });
        } catch (e) { console.warn('SW registration failed', e); }
      });
    }
  })();
  </script>
</body>
</html>
